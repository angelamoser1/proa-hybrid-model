# -*- coding: utf-8 -*-"""This script configures and runs the CADET-Process simulation for either a load and wash only (subprocess='BTC') or load-wash-elute (subprocess=LWE) simulation using the general rate model and colloidal isotherm. Non-pH dependent parameters can be used (use_pH_dependence=False) or pHdependent parameters can be used (use_pH_dependence=True).Options for the [H+] elution gradient are 'step' or 'linear'.The length of the elution step (or gradient) can be changed by using ms['elution_time'].Plotting and creation of an excel output are optional."""from CADETProcess.processModel import ComponentSystemfrom CADETProcess.processModel import MultiComponentColloidalfrom CADETProcess.processModel import Inlet, Outlet, GeneralRateModelfrom CADETProcess.processModel import FlowSheet, Processfrom CADETProcess.simulator import Cadetimport matplotlib.pyplot as pltimport pandas as pdimport numpy as npdef ms():    ms = {         'params': {        # pH dependent parameters        'pore_diff': [1.54],         'Ds0_exp': [0.00051],         'Ds1_exp': [93.031],         'lnKe0': [39.91],        'lnKe1': [-28.543],        'Bpp0': [8.7894],         'Bpp1': [-0.099],        # non-pH-dependent parameters (from experiment at pH 7.6)        # 'lnKe': [66.06],        # 'Bpp': [29.01],         # non-pH-dependent parameters (from pH dependent parameters solved at pH 7.6)        # use these for training because they will match up directly with pH dependence        'lnKe': [39.881],        'Bpp': [25.082],         },       'n_threads': 4,     'column_axial_nodes': 30,      'particle_nodes': 35,      'abstol': 1e-8,      'reltol': 1e-6,             'load_modifier': 7.6,      'wash_modifier': 7.6,      'elution_modifier': 3.489,          'col_id': 0.005,      'col_length': 0.018,       'Ep': 0.92,      'Ee': 0.34,      'particle_diameter': 5.41e-05,     'k_kin': 1e8,      'phase_ratio': 591000000.0,      'Ac_col': 1.9635e-05,      'feed_conc_mM': [0.03169],      'load_time': 4588.8,      'wash_time': 6988.8,      'elution_time': 7588.8, # 5 CVs: 7588.8,      'coord_num': 6,      'kappa': 4,     'flow_rate': [2.945e-09, 2.945e-09, 2.945e-09],      'r_hyd': [1.784e-10, 4.4875e-09],      'k_film': [[1.16098080e-04, 1.16098080e-04, 1.16098080e-04],           [1.33799353e-05, 1.33799353e-05, 1.33799353e-05]],       # CADET-process only allows one axial dispersion      # so we are using the protein one.     'Dax_col': [1.53157227e-08, 1.53157227e-08, 1.53157227e-08],                        'modifier_pore_diff': 7.060e-10,          'MW': 148         }             return msdef make_elution_gradient(ms, profile='step'):    wash_c = np.array([1e3*10**(-ms['wash_modifier'])] + [0 for c in ms['feed_conc_mM']])    eluent_c = np.array([1e3*10**(-ms['elution_modifier'])] + [0 for c in ms['feed_conc_mM']])        if profile == 'step':        step_poly = np.array(list(zip(eluent_c)))        ms['elution_gradient_poly'] = step_poly        elif profile == 'linear':        linear_slope = (eluent_c - wash_c)/(ms['elution_time'] - ms['wash_time'])        linear_poly = np.array(list(zip(wash_c, linear_slope)))        ms['elution_gradient_poly'] = linear_poly                  return ms   def configure_CADET_process(ms, subprocess, use_pH_dependence, profile):    comp_names = [f'protein{i+1}' for i in range(len(ms['feed_conc_mM']))]    component_system = ComponentSystem(['H+'] + comp_names)    process = make_flowsheet(ms, component_system, subprocess, use_pH_dependence)    ms = make_elution_gradient(ms, profile)    process = set_events(ms, subprocess, process)       return process        def set_binding_model(ms, component_system, use_pH_dependence=False):    n_comp = len(component_system.names)        binding_model = MultiComponentColloidal(component_system, name='MultiComponentColloidal')    binding_model.is_kinetic = True    binding_model.phase_ratio = ms['phase_ratio']    binding_model.kappa_exponential = 0    binding_model.kappa_factor = 0    binding_model.kappa_constant = ms['kappa']    binding_model.coordination_number = ms['coord_num']        binding_model.logkeq_ph_exponent = [0,] * n_comp    binding_model.logkeq_power_exponent = [0,] * n_comp    binding_model.logkeq_power_factor = [0,] * n_comp    binding_model.bpp_ph_exponent = [0,] * n_comp    binding_model.bpp_exponent_factor = [0,] * n_comp    binding_model.bpp_exponent_multiplier = [0,] * n_comp        if use_pH_dependence == True:        binding_model.logkeq_exponent_factor = [0,] + ms['params']['lnKe0']        binding_model.logkeq_exponent_multiplier = [0,] + ms['params']['lnKe1']        binding_model.bpp_power_exponent = [0,] + ms['params']['Bpp1']        binding_model.bpp_power_factor = [0,] + ms['params']['Bpp0']    else:        binding_model.logkeq_exponent_factor = [0,] + ms['params']['lnKe']        binding_model.logkeq_exponent_multiplier = [0,] * n_comp        binding_model.bpp_power_exponent = [0,] * n_comp        binding_model.bpp_power_factor = [0,] + ms['params']['Bpp']                binding_model.protein_radius = ms['r_hyd']    binding_model.kinetic_rate_constant = ms['k_kin']        binding_model.bound_states = [0,] + [1 for c in ms['feed_conc_mM']]        return binding_model    def set_column_model(ms, component_system, binding_model, use_pH_dependence=False):        column = GeneralRateModel(component_system, name='column')        column.discretization.ncol = ms['column_axial_nodes']    column.discretization.npar = ms['particle_nodes']            column.binding_model = binding_model        # all units of meters    column.length = ms['col_length']    column.diameter = ms['col_id']    column.cross_section_area = ms['Ac_col']    column.particle_radius = ms['particle_diameter'] / 2        column.bed_porosity = ms['Ee']    column.particle_porosity = ms['Ep']        column.axial_dispersion = ms['Dax_col'][0] # m^2/s    column.film_diffusion = [k[0] for k in ms['k_film']]    column.pore_diffusion = [ms['modifier_pore_diff']] + [i * 1e-12 for i in ms['params']['pore_diff']]        #### Surface diffusion    if use_pH_dependence == True:        column.surface_diffusion_dependence = 'LIQUID_SALT_EXPONENTIAL'        column.surface_diffusion = [i * 1e-12 for i in ms['params']['Ds0_exp']]        column.surface_diffusion_exponent_factor = column.n_bound_states*[1.0]        column.surface_diffusion_exponent_multiplier = ms['params']['Ds1_exp']    else:        pass        column.c = [1e3*10**(-ms['load_modifier'])] + [0 for c in ms['feed_conc_mM']]    column.cp = [1e3*10**(-ms['load_modifier'])] + [0 for c in ms['feed_conc_mM']]    column.q = [0 for c in ms['feed_conc_mM']]        return column        ###########################################################################    def make_flowsheet(ms, component_system, subprocess='BTC', use_pH_dependence=False):           binding_model = set_binding_model(ms, component_system, use_pH_dependence=use_pH_dependence)    column = set_column_model(ms, component_system, binding_model, use_pH_dependence=use_pH_dependence)    outlet = Outlet(component_system, name='outlet')        feed = Inlet(component_system, name='feed')    feed.c = [1e3*10**(-ms['load_modifier'])] + ms['feed_conc_mM']        wash = Inlet(component_system, name='wash')    wash.c = [1e3*10**(-ms['wash_modifier'])] + [0 for c in ms['feed_conc_mM']]        flow_sheet = FlowSheet(component_system)        flow_sheet.add_unit(feed)     flow_sheet.add_unit(wash)    flow_sheet.add_unit(column)    flow_sheet.add_unit(outlet)         flow_sheet.add_connection(feed, column)    flow_sheet.add_connection(wash, column)    flow_sheet.add_connection(column, outlet)        if subprocess == 'LWE':        eluent = Inlet(component_system, name='eluent')        eluent.c = [1e3*10**(-ms['elution_modifier'])] + [0 for c in ms['feed_conc_mM']]               flow_sheet.add_unit(eluent)        flow_sheet.add_connection(eluent, column)                cycle_time = ms['elution_time']            else:        cycle_time = ms['wash_time']            process = Process(flow_sheet, 'BTC')       process.cycle_time = cycle_time            return process    def set_events(ms, subprocess, process):          ### load ##################################################################     process.add_event(        'feed_on',        'flow_sheet.feed.flow_rate',        ms['flow_rate'][0],         time=0    )        ### wash ##################################################################        process.add_event(        'feed_off',        'flow_sheet.feed.flow_rate',        0,        time=ms['load_time']    )        process.add_event(        'wash_on',        'flow_sheet.wash.flow_rate',          ms['flow_rate'][1],          time=ms['load_time']    )        process.add_event(        'k_film_wash',        'flow_sheet.column.film_diffusion',        [k[1] for k in ms['k_film']],        time=ms['load_time']    )        process.add_event(        'Dax_col_wash',        'flow_sheet.column.axial_dispersion',        ms['Dax_col'][1],        time=ms['load_time']    )        process.add_event(        'wash_off',        'flow_sheet.wash.flow_rate',        0,        time=ms['wash_time']    )        ### elution ###############################################################        if subprocess == 'LWE':                process.add_event(            'elution_profile',            'flow_sheet.eluent.c',            ms['elution_gradient_poly'],            time=ms['wash_time']        )                process.add_event(            'eluent_on',            'flow_sheet.eluent.flow_rate',              ms['flow_rate'][2],              time=ms['wash_time']        )                process.add_event(            'k_film_elu',            'flow_sheet.column.film_diffusion',            [k[2] for k in ms['k_film']],            time=ms['wash_time']        )                process.add_event(            'Dax_col_elu',            'flow_sheet.column.axial_dispersion',            ms['Dax_col'][2],            time=ms['wash_time']        )                process.add_event(            'eluent_off',            'flow_sheet.eluent.flow_rate',              0,              time=ms['elution_time']        )        return processdef convert_time_to_CV(time_data, ms):    CV_data = np.zeros((len(time_data)))    CV = ms['col_length']*ms['Ac_col']    time_cumul = [0, ms['load_time'], ms['wash_time'], ms['elution_time'], time_data[-1]+1]    flow_rate  = [ms['flow_rate'][0]] + ms['flow_rate'] + [ms['flow_rate'][-1]]    for i in range(1, len(time_data)):        for j in range(1, len(time_cumul)):            if time_data[i] >= time_cumul[j-1] and time_data[i] < time_cumul[j]:                            CV_data[i] = CV_data[i-1] + (time_data[i] - time_data[i-1])*(flow_rate[j])/CV         return CV_datadef make_plot(simulation_results, ms):        solution_outlet = simulation_results.solution.column.outlet    process_time = solution_outlet.time/60    CVs = convert_time_to_CV(solution_outlet.time, ms)    process_H = solution_outlet.solution.T[0]    process_pH = -np.log10(process_H*0.001)    process_protein = solution_outlet.solution.T[1]    mg = process_protein*ms['MW']        fig, ax = plt.subplots(figsize=(7, 6))    ax2 = ax.twinx()        x_axis = CVs    y_axis = mg          ax.plot(CVs, y_axis, linewidth=2, color='k', label='protein')    # ax2.plot(x_axis, process_H, linewidth=2, color='r')    ax2.plot(x_axis, process_pH, linewidth=2, color='r', label='pH')        # fig.legend(bbox_to_anchor=(0.5, 0.7))        # ax.set_xlim(58, 63)        ax.set_xlabel('Column volumes')    ax.set_ylabel('Concentration [g/L]')       ax.tick_params(direction="in")        ax.tick_params(axis='x', colors='black')    ax.tick_params(axis='y', colors='black')     ax2.set_ylabel('pH')            ax2.tick_params(direction="in")        ax2.tick_params(axis='y', colors='red')       ax2.yaxis.label.set_color('red')    # ax2.set_ylim(3, 8)        fig.tight_layout()       plt.savefig('plot.svg', dpi=300)      def make_excel(ms, simulation_results):    solution_outlet = simulation_results.solution.column.outlet    CVs = convert_time_to_CV(solution_outlet.time, ms)    process_H = solution_outlet.solution.T[0]    process_pH = -np.log10(process_H*0.001)    process_protein = solution_outlet.solution.T[1]    mg = process_protein*ms['MW']        # Create a DataFrame from the NumPy arrays    df = pd.DataFrame({        'CVs': CVs,        'pH': process_pH,        'Protein C mg/mL': mg,    })        # Save the DataFrame to an Excel file    df.to_excel('output.xlsx', index=False, engine='openpyxl')       def run(ms, subprocess, profile, use_pH_dependence, plot=True, make_excel=False):    # define the process    process = configure_CADET_process(ms,                                       subprocess=subprocess,                                       use_pH_dependence=use_pH_dependence,                                      profile=profile                                      )    simulator = Cadet()    simulator.solver_parameters.nthreads = ms['n_threads']        print('\nCADET-Process simulation running!\n')        simulation_results = simulator.simulate(process, file_path='PrismA_GmAbA.h5')        print(f'Simulation completed in {simulation_results.time_elapsed:.2f} seconds.\n')        if plot == True:        make_plot(simulation_results, ms)        if make_excel == True:        make_excel(simulation_results)          return simulation_resultsif __name__ == '__main__':    ms = ms()      run(ms, subprocess='LWE', profile='linear', use_pH_dependence=True)