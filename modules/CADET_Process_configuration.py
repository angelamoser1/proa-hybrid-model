# -*- coding: utf-8 -*-"""This is the CADET-Process configuration for the Protein A Model.This script is used to set up the model that will be used for both forwardsimulations and for fitting. The model contains only 2 unit operations:tubing and the column. No CSTR is included because a CSTR is not generally in line and mixing effects are simulated prior to resin titration. During elution, an inlet concentration profile is supplied for pH, where mixing and resin titration effects have been accounted for.Length of tubing can be different for the load/wash and elution sections."""import numpy as npfrom CADETProcess.processModel import ComponentSystemfrom CADETProcess.processModel import MultiComponentColloidalfrom CADETProcess.processModel import Inlet, Outlet, GeneralRateModel, TubularReactorfrom CADETProcess.processModel import FlowSheet, Processfrom CADETProcess.simulator import Cadetfrom CADETProcess.reference import ReferenceIOfrom CADETProcess.comparison import Comparatorfrom CADETProcess.optimization import OptimizationProblemfrom CADETProcess.optimization import U_NSGA3from CADETProcess.optimization import Joblibdef add_elution_H_profile(ms, process, profile):     if profile == 'user_defined':        time = ms['H_time_data']        c = ms['H_data']        elif profile == 'simulated':        # shift back by the column HUV from column sim (already correct it seems)        # column_HUV = (ms['Ee']+(1-ms['Ee'])*ms['Ep'])*ms['col_length']*ms['Ac_col']        # timeshift = column_HUV/ms['flow_rate'][2]        time = ms['column_out']['time']*60 + ms['wash_time'] #- timeshift        c = ms['column_out']['cH'] * 1e3 # convert M to mM     else:        return process        # Cut off the end if it falls outside of the elution section    mask = time <= ms['elution_time']    trimmed_time = time[mask]    trimmed_c = c[mask]    process.add_concentration_profile(unit='eluent',time=trimmed_time,                                      c=trimmed_c, components=['H+',], s=1e-10)          return processdef make_elution_gradient(ms, profile='step'):    wash_c = np.array([1e3*10**(-ms['wash_pH'])] + [0 for c in ms['feed_conc_mM']])    eluent_c = np.array([1e3*10**(-ms['elution_pH'])] + [0 for c in ms['feed_conc_mM']])        if profile == 'step':        step_poly = np.array(list(zip(eluent_c)))        ms['elution_gradient_poly'] = step_poly        elif profile == 'linear':        linear_slope = (eluent_c - wash_c)/(ms['elution_time'] - ms['wash_time'])        linear_poly = np.array(list(zip(wash_c, linear_slope)))        ms['elution_gradient_poly'] = linear_poly            else:        pass                 return ms        def set_binding_model(ms, component_system, use_pH_dependence=False):    n_comp = len(component_system.names)        binding_model = MultiComponentColloidal(component_system, name='MultiComponentColloidal')    binding_model.is_kinetic = True    binding_model.phase_ratio = ms['phase_ratio']    binding_model.kappa_exponential = 0    binding_model.kappa_factor = 0    binding_model.kappa_constant = ms['kappa']    binding_model.coordination_number = ms['coord_num']        binding_model.logkeq_ph_exponent = [0,] * n_comp    binding_model.logkeq_power_exponent = [0,] * n_comp    binding_model.logkeq_power_factor = [0,] * n_comp    binding_model.bpp_ph_exponent = [0,] * n_comp    binding_model.bpp_exponent_factor = [0,] * n_comp    binding_model.bpp_exponent_multiplier = [0,] * n_comp        if use_pH_dependence == True:        binding_model.logkeq_exponent_factor = [0,] + ms['params']['lnKe0']        binding_model.logkeq_exponent_multiplier = [0,] + ms['params']['lnKe1']        binding_model.bpp_power_exponent = [0,] + ms['params']['Bpp1']        binding_model.bpp_power_factor = [0,] + ms['params']['Bpp0']    else:        binding_model.logkeq_exponent_factor = [0,] + ms['params']['lnKe']        binding_model.logkeq_exponent_multiplier = [0,] * n_comp        binding_model.bpp_power_exponent = [0,] * n_comp        binding_model.bpp_power_factor = [0,] + ms['params']['Bpp']    binding_model.protein_radius = [0,] + list(ms['r_hyd'][1:])    binding_model.kinetic_rate_constant = ms['k_kin_colloidal']        binding_model.bound_states = [0,] + [1 for c in ms['feed_conc_mM']]        return binding_model    def set_column_model(ms, component_system, binding_model, use_pH_dependence=False):     column = GeneralRateModel(component_system, name='column')        column.discretization.ncol = ms['column_axial_nodes']    column.discretization.npar = ms['particle_nodes']            column.binding_model = binding_model        # all units of meters    column.length = ms['col_length']    column.diameter = ms['col_id']    column.cross_section_area = ms['Ac_col']    column.particle_radius = ms['particle_diameter'] / 2        column.bed_porosity = ms['Ee']    column.particle_porosity = ms['Ep']        # using the axial dispersion of the first component, which should be the main protein    column.axial_dispersion = ms['Dax_col'][1][0] # m^2/s    column.film_diffusion = [k[0] for k in ms['k_film']]    column.pore_diffusion = [ms['modifier_pore_diff']] + [i * 1e-12 for i in ms['params']['pore_diff']]        #### Surface diffusion    if use_pH_dependence == True:        column.surface_diffusion_dependence = 'LIQUID_SALT_EXPONENTIAL'        column.surface_diffusion = [i * 1e-12 for i in ms['params']['Ds0']]        column.surface_diffusion_exponent_factor = column.n_bound_states*[1.0]        column.surface_diffusion_exponent_multiplier = ms['params']['Ds1']    else:        column.surface_diffusion = [i * 1e-12 for i in ms['params']['Ds']]        column.c = [1e3*10**(-ms['load_pH'])] + [0 for c in ms['feed_conc_mM']]    column.cp = [1e3*10**(-ms['load_pH'])] + [0 for c in ms['feed_conc_mM']]    column.q = [0 for c in ms['feed_conc_mM']]        return column    def set_load_tubing(ms, component_system):    load_tubing = TubularReactor(component_system, name='load_tubing')       load_tubing.length = ms['load_tubing_length']    load_tubing.diameter = ms['load_tubing_id']    load_tubing.axial_dispersion = ms['load_tubing_Dax'][1][0]    return load_tubingdef set_elution_tubing(ms, component_system):    elu_tubing = TubularReactor(component_system, name='elu_tubing')        elu_tubing.length = ms['elu_tubing_length']    elu_tubing.diameter = ms['elu_tubing_id']    elu_tubing.axial_dispersion = ms['elu_tubing_Dax'][1][0]        return elu_tubing    def make_flowsheet(ms, component_system, subprocess='BTC', use_pH_dependence=False):           binding_model = set_binding_model(ms, component_system, use_pH_dependence=use_pH_dependence)    column = set_column_model(ms, component_system, binding_model, use_pH_dependence=use_pH_dependence)    outlet = Outlet(component_system, name='outlet')        feed = Inlet(component_system, name='feed')    feed.c = [1e3*10**(-ms['load_pH'])] + ms['feed_conc_mM']        wash = Inlet(component_system, name='wash')    wash.c = [1e3*10**(-ms['wash_pH'])] + [0 for c in ms['feed_conc_mM']]        flow_sheet = FlowSheet(component_system)        flow_sheet.add_unit(feed)     flow_sheet.add_unit(wash)    flow_sheet.add_unit(column)    flow_sheet.add_unit(outlet)         flow_sheet.add_connection(column, outlet)        # If load tubing is included, add and connect it    if ms['load_tubing_length'] != 0:        load_tubing = set_load_tubing(ms, component_system)        flow_sheet.add_unit(load_tubing)           flow_sheet.add_connection(feed, load_tubing)        flow_sheet.add_connection(wash, load_tubing)        flow_sheet.add_connection(load_tubing, column)    else:          flow_sheet.add_connection(feed, column)        flow_sheet.add_connection(wash, column)        # If elution is included in process, add eluent    if subprocess == 'LWE':        eluent = Inlet(component_system, name='eluent')        eluent.c = [1e3*10**(-ms['elution_pH'])] + [0 for c in ms['feed_conc_mM']]                flow_sheet.add_unit(eluent)                # If elution tubing is included, add and connect it        if ms['elu_tubing_length'] != 0:            elu_tubing = set_elution_tubing(ms, component_system)            flow_sheet.add_unit(elu_tubing)             flow_sheet.add_connection(eluent, elu_tubing)            flow_sheet.add_connection(elu_tubing, column)        else:            flow_sheet.add_connection(eluent, column)                cycle_time = ms['elution_time']            else:        cycle_time = ms['wash_time']            process = Process(flow_sheet, 'ProA')       process.cycle_time = cycle_time            return process    def set_events(ms, subprocess, process):          ### load ##################################################################    process.add_event(        'feed_on',        'flow_sheet.feed.flow_rate',        ms['flow_rate'][0],         time=0    )        ### wash ##################################################################        process.add_event(        'feed_off',        'flow_sheet.feed.flow_rate',        0,        time=ms['load_time']    )            process.add_event(        'wash_on',        'flow_sheet.wash.flow_rate',          ms['flow_rate'][1],          time=ms['load_time']    )        process.add_event(        'k_film_wash',        'flow_sheet.column.film_diffusion',        [k[1] for k in ms['k_film']],        time=ms['load_time']    )        process.add_event(        'Dax_col_wash',        'flow_sheet.column.axial_dispersion',        ms['Dax_col'][1][1],        time=ms['load_time']    )        process.add_event(        'wash_off',        'flow_sheet.wash.flow_rate',        0,        time=ms['wash_time']    )        ### elution ###############################################################        if subprocess == 'LWE':                        process.add_event(            'eluent_on',            'flow_sheet.eluent.flow_rate',              ms['flow_rate'][2],              time=ms['wash_time']        )                process.add_event(            'k_film_elu',            'flow_sheet.column.film_diffusion',            [k[2] for k in ms['k_film']],            time=ms['wash_time']        )                process.add_event(            'Dax_col_elu',            'flow_sheet.column.axial_dispersion',            ms['Dax_col'][1][2],            time=ms['wash_time']        )                process.add_event(            'eluent_off',            'flow_sheet.eluent.flow_rate',              0,              time=ms['elution_time']        )                if ms.get('elution_gradient_poly') is not None:                   process.add_event(                'elution_profile',                'flow_sheet.eluent.c',                ms['elution_gradient_poly'],                time=ms['wash_time']            )                                  return process    ############################################################################### def fit(ms_list, processes, simulator, use_pH_dependence):     # run simulation and calculate objective for each experiment    for exp in range(len(ms_list)):        ms = ms_list[exp]        process = processes[exp]                    # RUN SIMULATION        simulation_results = simulator.simulate(process)                t_data = ms['conc_time_data']        prot_data = ms['conc_data_mM']            # creating a dummy column for H+ because there is no experimental data for this        H_dummy_data = np.array([np.zeros(len(prot_data[0]))])            c_data = np.stack((H_dummy_data, prot_data)).T              reference = ReferenceIO(name='c experiment', time=t_data, solution=c_data,                                 component_system=process.component_system)                # use all components except for the first (proton) for fitting        comps_to_fit = process.component_system.names[1:]                comparator = Comparator()        comparator.add_reference(reference)        comparator.add_difference_metric(            'NRMSE', reference, 'outlet.inlet',            components=comps_to_fit        )                comparator.plot_comparison(simulation_results)        #######################################################################        optimization_problem = OptimizationProblem('fit_parameters')        for i in range(len(processes)):        optimization_problem.add_evaluation_object(processes[i], name=f'process_{i}')        # Always check pore diffusivity       if ms['bounds'].get('pore_diff') is not None:        for idx, bound in enumerate(ms['bounds']['pore_diff']):            optimization_problem.add_variable(                name=f'pore_diff_{idx+1}',                 parameter_path='flow_sheet.column.pore_diffusion',                lb=bound[0] * 1e-12, ub=bound[1] * 1e-12,                transform='auto'            )        #### Non-pH-dependent parameters    if use_pH_dependence == False:                if ms['bounds'].get('Ds') is not None:            for idx, bound in enumerate(ms['bounds']['Ds']):                optimization_problem.add_variable(                    name=f'Ds_{idx}',                     parameter_path='flow_sheet.column.surface_diffusion',                    lb=bound[0], ub=bound[1],                    transform='auto'                )                        if ms['bounds'].get('lnKe') is not None:            for idx, bound in enumerate(ms['bounds']['lnKe']):                optimization_problem.add_variable(                    name=f'lnKe_{idx+1}',                     parameter_path='flow_sheet.column.binding_model.logkeq_exponent_factor',                    lb=bound[0], ub=bound[1],                    transform='auto'                )                if ms['bounds'].get('Bpp') is not None:            for idx, bound in enumerate(ms['bounds']['Bpp']):                optimization_problem.add_variable(                    name=f'Bpp_{idx+1}',                     parameter_path='flow_sheet.column.binding_model.bpp_power_factor',                    lb=bound[0], ub=bound[1],                    transform='auto'                )            #### pH-dependent parameters    elif use_pH_dependence == True:                if ms['bounds'].get('lnKe0') is not None:            for idx, bound in enumerate(ms['bounds']['lnKe0']):                optimization_problem.add_variable(                    name=f'lnKe0_{idx+1}',                     parameter_path='flow_sheet.column.binding_model.logkeq_exponent_factor',                    lb=bound[0], ub=bound[1],                    transform='auto'                )                if ms['bounds'].get('lnKe1') is not None:            for idx, bound in enumerate(ms['bounds']['lnKe1']):                optimization_problem.add_variable(                    name=f'lnKe1_{idx+1}',                     parameter_path='flow_sheet.column.binding_model.logkeq_exponent_multiplier',                    lb=bound[0], ub=bound[1],                    transform='auto'                )            if ms['bounds'].get('Bpp0') is not None:            for idx, bound in enumerate(ms['bounds']['Bpp0']):                optimization_problem.add_variable(                    name=f'Bpp0_{idx+1}',                     parameter_path='flow_sheet.column.binding_model.bpp_power_factor',                    lb=bound[0], ub=bound[1],                    transform='auto'                )                if ms['bounds'].get('Bpp1') is not None:            for idx, bound in enumerate(ms['bounds']['Bpp1']):                optimization_problem.add_variable(                    name=f'Bpp1_{idx+1}',                     parameter_path='flow_sheet.column.binding_model.bpp_power_exponent',                    lb=bound[0], ub=bound[1],                    transform='auto'                )                        if ms['bounds'].get('Ds0') is not None:            for idx, bound in enumerate(ms['bounds']['Ds0']):                optimization_problem.add_variable(                    name=f'Ds0_{idx}',                     parameter_path='flow_sheet.column.surface_diffusion',                    lb=bound[0], ub=bound[1],                    transform='auto'                )                if ms['bounds'].get('Ds1') is not None:            for idx, bound in enumerate(ms['bounds']['Ds1']):                optimization_problem.add_variable(                    name=f'Ds1_{idx}',                     parameter_path='flow_sheet.column.surface_diffusion_exponent_multiplier',                    lb=bound[0], ub=bound[1],                    transform='auto'                )    optimization_problem.add_evaluator(simulator)        optimization_problem.add_objective(        comparator,        n_objectives=comparator.n_metrics,        requires=[simulator]    )        def callback(simulation_results, individual, evaluation_object, callbacks_dir='../output'):        comparator.plot_comparison(            simulation_results,            file_name=f'{callbacks_dir}/{individual.id}_{evaluation_object}_comparison.png',            show=True        )            optimization_problem.add_callback(callback, requires=[simulator])        optimizer = U_NSGA3()    # print(optimizer.options)        # parallelize!!    optimizer.backend = Joblib(n_cores=4)        ### try to use hopsy but bypass when hopsy isn't working ##################    def generate_samples(lower_boundaries, upper_boundaries, samples=50,):        samples = np.random.random((samples, len(upper_boundaries)))        transformed_samples = samples * (upper_boundaries - lower_boundaries) + lower_boundaries        return transformed_samples    try:        # first try using hopsy        optimization_results = optimizer.optimize(                optimization_problem,                use_checkpoint=False,            )    except:        # if this fails generate samples manually with np.random        print('\nhopsy error, samples generated with np.random\n')        pop_size = optimizer.get_population_size(optimization_problem)                x0 = generate_samples(np.array(optimization_problem.lower_bounds),                              np.array(optimization_problem.upper_bounds),                              samples=pop_size)        optimization_results = optimizer.optimize(                optimization_problem,                use_checkpoint=False,                x0 = x0,            )        return optimization_results###############################################################################def configure_CADET_process(ms, subprocess, use_pH_dependence, profile):    comp_names = [f'protein{i+1}' for i in range(len(ms['feed_conc_mM']))]    component_system = ComponentSystem(['H+'] + comp_names)    process = make_flowsheet(ms, component_system, subprocess, use_pH_dependence)        ms = make_elution_gradient(ms, profile)    process = set_events(ms, subprocess, process)    if subprocess == 'LWE':        process = add_elution_H_profile(ms, process, profile)    return process  def run(ms_list, subprocess, profile, use_pH_dependence):    processes = []    for ms in ms_list:        # define the process        process = configure_CADET_process(ms,                                           subprocess=subprocess,                                           use_pH_dependence=use_pH_dependence,                                          profile=profile                                          )        processes.append(process)            simulator = Cadet()    simulator.solver_parameters.nthreads = ms['n_threads']    simulator.solver_parameters.abstol = ms['abstol']    simulator.solver_parameters.reltol = ms['reltol']    print('\nCADET-Process simulation running!\n')        # run fitting if user selected run type 'fit'      if ms['run_type'] == 'fit':        all_solutions = fit(ms_list, processes, simulator, use_pH_dependence)        # if user selected run type 'forward', no fitting, just take sim result    else:        all_solutions = []        for process in processes:            simulation_results = simulator.simulate(process, file_path='model.h5')              all_solutions.append(simulation_results)            _ = simulation_results.solution.outlet.plot                print(f'Simulation completed in {simulation_results.time_elapsed:.2f} seconds.\n')             return all_solutions'\n'                                                                        